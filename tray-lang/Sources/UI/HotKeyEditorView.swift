//
//  HotKeyEditorView.swift
//  tray-lang
//
//  Created by s00d on 01.08.2025.
//

import SwiftUI
import AppKit

struct HotKeyEditorView: View {
    @ObservedObject var coordinator: AppCoordinator
    @Environment(\.dismiss) private var dismiss
    @State private var isCapturing = false
    @State private var capturedKey: String = ""
    @State private var capturedModifiers: String = ""
    @State private var capturedKeyCode: Int?
    @State private var capturedModifiersArray: [CGEventFlags] = []
    
    var availableKeyCodes: [KeyInfo] {
        return KeyUtils.getAvailableKeyCodes()
    }
    
    var availableModifiers: [(CGEventFlags, String)] {
        return KeyUtils.getAvailableModifiers()
    }
    
    var body: some View {
        VStack(spacing: 0) {
            HStack {
                Text("Hotkey Editor")
                    .font(.title2)
                    .fontWeight(.bold)
                Spacer()
                Button("‚úï") { dismiss() }
                    .buttonStyle(.plain)
            }
            .padding()
            Divider()
            
            VStack(spacing: 20) {
                // Current/Selected combination display
                Group {
                    if let keyCode = capturedKeyCode, !capturedModifiersArray.isEmpty {
                        // Show captured combination
                        let hotKey = HotKey(keyCode: keyCode, modifiers: capturedModifiersArray)
                        VStack(alignment: .leading, spacing: 8) {
                            Text("Selected Combination")
                                .font(.headline)
                                .foregroundColor(.secondary)
                            Text(hotKey.displayString)
                                .font(.system(.title2, design: .monospaced))
                                .fontWeight(.medium)
                                .padding()
                                .frame(maxWidth: .infinity, alignment: .leading)
                                .background(Color.green.opacity(0.1))
                                .cornerRadius(8)
                        }
                    } else {
                        VStack(alignment: .leading, spacing: 8) {
                            Text("Current Combination")
                                .font(.headline)
                                .foregroundColor(.secondary)
                            Text(coordinator.hotKey.displayString)
                                .font(.system(.title2, design: .monospaced))
                                .fontWeight(.medium)
                                .padding()
                                .frame(maxWidth: .infinity, alignment: .leading)
                                .background(Color.gray.opacity(0.1))
                                .cornerRadius(8)
                        }
                    }
                }
                .padding(.horizontal)
                
                // Capture section
                VStack(spacing: 12) {
                    Text("Capture New Hotkey")
                        .font(.headline)
                        .foregroundColor(.secondary)
                    
                    Button(isCapturing ? "Stop Capture" : "Start Capture") {
                        if isCapturing {
                            stopCapturing()
                        } else {
                            startCapturing()
                        }
                    }
                    .buttonStyle(.bordered)
                    .controlSize(.large)
                    
                    if isCapturing {
                        Text("Press any key combination...")
                            .font(.caption)
                            .foregroundColor(.secondary)
                    }
                }
                .padding(.horizontal)
                
                Spacer()
            }
            .padding(.vertical)
            
            Divider()
            
            HStack {
                Button("Cancel") {
                    dismiss()
                }
                .buttonStyle(.plain)
                
                Spacer()
                
                Button("Confirm") {
                    if let keyCode = capturedKeyCode, !capturedModifiersArray.isEmpty {
                        coordinator.hotKey = HotKey(keyCode: keyCode, modifiers: capturedModifiersArray)
                        coordinator.saveHotKey()
                        
                        // –ü–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞–µ–º –∑–∞—Ö–≤–∞—Ç –∫–ª–∞–≤–∏—à –ø–æ—Å–ª–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Ö–æ—Ç–∫–µ—è
                        DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
                            coordinator.startKeyCapture()
                        }
                    }
                    dismiss()
                }
                .buttonStyle(.borderedProminent)
                .disabled(capturedKeyCode == nil || capturedModifiersArray.isEmpty)
            }
            .padding()
        }
        .frame(width: 350, height: 300)
        .onReceive(NotificationCenter.default.publisher(for: .keyCaptured)) { notification in
            print("üì® –ü–æ–ª—É—á–µ–Ω–æ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ –∑–∞—Ö–≤–∞—Ç–µ –∫–ª–∞–≤–∏—à–∏")
            print("üîç isCapturing: \(isCapturing)")
            
            if isCapturing {
                print("üìã userInfo: \(notification.userInfo ?? [:])")
                
                if let keyCode = notification.userInfo?["keyCode"] as? Int,
                   let modifiers = notification.userInfo?["modifiers"] as? [CGEventFlags],
                   keyCode > 0 { // –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º —Å–æ–±—ã—Ç–∏—è —Å keyCode = 0
                    print("‚úÖ –£—Å–ø–µ—à–Ω–æ –∏–∑–≤–ª–µ—á–µ–Ω—ã –¥–∞–Ω–Ω—ã–µ: keyCode=\(keyCode), modifiers=\(modifiers)")
                    capturedKeyCode = keyCode
                    capturedModifiersArray = modifiers
                    stopCapturing()
                } else {
                    print("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –∏–∑–≤–ª–µ—á—å –¥–∞–Ω–Ω—ã–µ –∏–∑ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –∏–ª–∏ keyCode = 0")
                    print("üìã –¢–∏–ø—ã –¥–∞–Ω–Ω—ã—Ö: keyCode=\(type(of: notification.userInfo?["keyCode"])), modifiers=\(type(of: notification.userInfo?["modifiers"]))")
                }
            } else {
                print("‚ö†Ô∏è –ó–∞—Ö–≤–∞—Ç –Ω–µ –∞–∫—Ç–∏–≤–µ–Ω, –∏–≥–Ω–æ—Ä–∏—Ä—É–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ")
            }
        }
        .onDisappear {
            stopCapturing()
        }
        .background(
            // –õ–æ–∫–∞–ª—å–Ω—ã–π –∑–∞—Ö–≤–∞—Ç –∫–ª–∞–≤–∏—à —á–µ—Ä–µ–∑ NSEvent
            KeyCaptureView(isCapturing: $isCapturing)
        )
    }
    
    private func startCapturing() {
        print("üéØ –ù–∞—á–∏–Ω–∞–µ–º –∑–∞—Ö–≤–∞—Ç –∫–ª–∞–≤–∏—à...")
        isCapturing = true
        capturedKeyCode = nil
        capturedModifiersArray = []
        print("‚úÖ –õ–æ–∫–∞–ª—å–Ω—ã–π –∑–∞—Ö–≤–∞—Ç –∫–ª–∞–≤–∏—à –∑–∞–ø—É—â–µ–Ω —É—Å–ø–µ—à–Ω–æ")
    }
    
    private func stopCapturing() {
        isCapturing = false
        coordinator.stopKeyCapture()
    }
}

// MARK: - Notifications
extension Notification.Name {
    static let keyCaptured = Notification.Name("keyCaptured")
}

// –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω–æ–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ –¥–ª—è –∑–∞—Ö–≤–∞—Ç–∞ –∫–ª–∞–≤–∏—à
struct KeyCaptureView: NSViewRepresentable {
    @Binding var isCapturing: Bool
    
    func makeNSView(context: Context) -> NSView {
        let view = NSView()
        return view
    }
    
    func updateNSView(_ nsView: NSView, context: Context) {
        // –û—á–∏—â–∞–µ–º –ø—Ä–µ–¥—ã–¥—É—â–∏–π –º–æ–Ω–∏—Ç–æ—Ä
        context.coordinator.cleanup()
        
        if isCapturing {
            // –î–æ–±–∞–≤–ª—è–µ–º –ª–æ–∫–∞–ª—å–Ω—ã–π –º–æ–Ω–∏—Ç–æ—Ä —Å–æ–±—ã—Ç–∏–π
            context.coordinator.monitor = NSEvent.addLocalMonitorForEvents(matching: .keyDown) { event in
                let keyCode = Int(event.keyCode)
                let flags = event.modifierFlags
                
                print("üîç –õ–æ–∫–∞–ª—å–Ω—ã–π –∑–∞—Ö–≤–∞—Ç: –ö–ª–∞–≤–∏—à–∞ \(keyCode), –§–ª–∞–≥–∏ \(flags.rawValue)")
                
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ keyCode –≤–∞–ª–∏–¥–Ω—ã–π
                guard keyCode > 0 else {
                    print("‚ö†Ô∏è –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º —Å–æ–±—ã—Ç–∏–µ —Å keyCode = 0")
                    return event
                }
                
                // –°–æ–±–∏—Ä–∞–µ–º –≤—Å–µ –∞–∫—Ç–∏–≤–Ω—ã–µ –º–æ–¥–∏—Ñ–∏–∫–∞—Ç–æ—Ä—ã
                var modifiers: [CGEventFlags] = []
                if flags.contains(.command) {
                    modifiers.append(.maskCommand)
                    print("  - Command")
                }
                if flags.contains(.shift) {
                    modifiers.append(.maskShift)
                    print("  - Shift")
                }
                if flags.contains(.option) {
                    modifiers.append(.maskAlternate)
                    print("  - Option")
                }
                if flags.contains(.control) {
                    modifiers.append(.maskControl)
                    print("  - Control")
                }
                
                print("üìã –°–æ–±—Ä–∞–Ω–Ω—ã–µ –º–æ–¥–∏—Ñ–∏–∫–∞—Ç–æ—Ä—ã: \(modifiers.map { $0.rawValue })")
                
                // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ —Å –∑–∞—Ö–≤–∞—á–µ–Ω–Ω—ã–º–∏ –¥–∞–Ω–Ω—ã–º–∏
                DispatchQueue.main.async {
                    NotificationCenter.default.post(
                        name: .keyCaptured,
                        object: nil,
                        userInfo: [
                            "keyCode": keyCode,
                            "modifiers": modifiers
                        ]
                    )
                    print("üì§ –û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ –∑–∞—Ö–≤–∞—Ç–µ –∫–ª–∞–≤–∏—à–∏: \(keyCode)")
                }
                
                return nil // –ü–æ–≥–ª–æ—â–∞–µ–º —Å–æ–±—ã—Ç–∏–µ
            }
        }
    }
    
    func makeCoordinator() -> Coordinator {
        Coordinator()
    }
    
    class Coordinator {
        var monitor: Any?
        
        func cleanup() {
            if let monitor = monitor {
                NSEvent.removeMonitor(monitor)
                self.monitor = nil
            }
        }
        
        deinit {
            cleanup()
        }
    }
} 